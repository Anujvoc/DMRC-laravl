/**
 * ApexCharts - Minimal implementation for advanced charts
 * Basic chart functionality for admin dashboard
 */

window.ApexCharts = window.ApexCharts || {};

ApexCharts = class ApexCharts {
    constructor(element, options = {}) {
        this.element = element;
        this.options = {
            chart: {
                type: 'line',
                width: '100%',
                height: 'auto'
            },
            series: [],
            xaxis: {
                categories: []
            },
            ...options
        };
        this.init();
    }
    
    init() {
        this.render();
    }
    
    render() {
        const canvas = document.createElement('canvas');
        canvas.width = this.element.offsetWidth || 400;
        canvas.height = this.options.chart.height || 300;
        
        this.element.innerHTML = '';
        this.element.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        this.drawChart(ctx);
    }
    
    drawChart(ctx) {
        const width = canvas.width;
        const height = canvas.height;
        const type = this.options.chart.type;
        const series = this.options.series;
        const categories = this.options.xaxis.categories;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        if (type === 'line' || type === 'area') {
            this.drawLineChart(ctx, width, height, series, categories, type === 'area');
        } else if (type === 'bar') {
            this.drawBarChart(ctx, width, height, series, categories);
        } else if (type === 'donut' || type === 'pie') {
            this.drawPieChart(ctx, width, height, series[0].data, type === 'donut');
        }
    }
    
    drawLineChart(ctx, width, height, series, categories, fillArea) {
        const padding = 40;
        const chartWidth = width - padding * 2;
        const chartHeight = height - padding * 2;
        const pointSpacing = chartWidth / (categories.length - 1);
        
        // Find max value for scaling
        let maxValue = 0;
        series.forEach(s => {
            maxValue = Math.max(maxValue, ...s.data);
        });
        
        // Draw grid lines
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
            const y = padding + (chartHeight / 5) * i;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(width - padding, y);
            ctx.stroke();
        }
        
        // Draw each series
        series.forEach((serie, seriesIndex) => {
            ctx.strokeStyle = this.getColor(seriesIndex);
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            serie.data.forEach((value, index) => {
                const x = padding + index * pointSpacing;
                const y = padding + chartHeight - (value / maxValue) * chartHeight;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Fill area if needed
            if (fillArea) {
                ctx.fillStyle = this.getColor(seriesIndex) + '20';
                ctx.lineTo(width - padding, height - padding);
                ctx.lineTo(padding, height - padding);
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw points
            ctx.fillStyle = this.getColor(seriesIndex);
            serie.data.forEach((value, index) => {
                const x = padding + index * pointSpacing;
                const y = padding + chartHeight - (value / maxValue) * chartHeight;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        });
        
        // Draw labels
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        categories.forEach((label, index) => {
            const x = padding + index * pointSpacing;
            ctx.fillText(label, x, height - 10);
        });
    }
    
    drawBarChart(ctx, width, height, series, categories) {
        const padding = 40;
        const chartWidth = width - padding * 2;
        const chartHeight = height - padding * 2;
        const barGroupWidth = chartWidth / categories.length;
        const barWidth = barGroupWidth / series.length * 0.8;
        
        let maxValue = 0;
        series.forEach(s => {
            maxValue = Math.max(maxValue, ...s.data);
        });
        
        series.forEach((serie, seriesIndex) => {
            ctx.fillStyle = this.getColor(seriesIndex);
            
            serie.data.forEach((value, index) => {
                const x = padding + index * barGroupWidth + seriesIndex * barWidth + barWidth * 0.1;
                const barHeight = (value / maxValue) * chartHeight;
                const y = padding + chartHeight - barHeight;
                
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Draw value on top
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x + barWidth / 2, y - 5);
                ctx.fillStyle = this.getColor(seriesIndex);
            });
        });
        
        // Draw labels
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        categories.forEach((label, index) => {
            const x = padding + index * barGroupWidth + barGroupWidth / 2;
            ctx.fillText(label, x, height - 10);
        });
    }
    
    drawPieChart(ctx, width, height, data, donut) {
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 2 - 40;
        const innerRadius = donut ? radius * 0.6 : 0;
        
        const total = data.reduce((sum, item) => sum + item, 0);
        let currentAngle = -Math.PI / 2;
        
        data.forEach((value, index) => {
            const sliceAngle = (value / total) * Math.PI * 2;
            
            // Draw slice
            ctx.fillStyle = this.getColor(index);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
            if (donut) {
                ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
            }
            ctx.closePath();
            ctx.fill();
            
            // Draw label
            const labelAngle = currentAngle + sliceAngle / 2;
            const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
            const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(value, labelX, labelY);
            
            currentAngle += sliceAngle;
        });
    }
    
    getColor(index) {
        const colors = ['#007bff', '#28a745', '#ffc107', '#dc3545', '#6f42c1', '#fd7e14', '#20c997', '#6c757d'];
        return colors[index % colors.length];
    }
    
    updateOptions(newOptions) {
        this.options = { ...this.options, ...newOptions };
        this.render();
    }
    
    updateSeries(newSeries) {
        this.options.series = newSeries;
        this.render();
    }
};
